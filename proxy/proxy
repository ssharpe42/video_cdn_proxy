#!/usr/bin/env python

import select
import sys
import thread

from io_utils import *
from socket_utils import socket_bind_listen, socket_bind_connect, receive
from vid_utils import *

MAX_SIZE = 512000  # Maximum bits to receive
SERVER_PORT = 8080
FAKE_PORT = 0
INIT_TP = 0.0  # Initial throughput value
MANIFEST_FILE = '/var/www/vod/big_buck_bunny.f4m'


class Proxy:
    """Proxy Class"""

    def __init__(self, log_file, alpha, listen_port, fake_ip, server_ip):

        # Set all inputs
        self.listen_port = listen_port
        self.fake_ip = fake_ip
        self.server_ip = server_ip
        self.alpha = alpha
        self.log_file = log_file

        self.read_manifest()

        self.tp_estimate = min(self.bitrates)

    def read_manifest(self):

        manifest = open(MANIFEST_FILE, 'r').read()
        self.bitrates = parse_f4m(manifest)

    def run(self):

        """ Run proxy """

        # Bind and listen for clients
        self.client_socket = socket_bind_listen('', self.listen_port)

        print 'Proxy listening for client connections...'

        # Loop to keep accepting connections
        while True:
            # Accept client connection
            client, addr = self.client_socket.accept()
            print 'Connected to client at:', client.getpeername()

            print 'Staring thread...'
            thread.start_new_thread(self.single_proxy, (client,))

    def single_proxy(self, client):

        # Bind to fake ip and connect to server
        server = socket_bind_connect(self.fake_ip, FAKE_PORT, self.server_ip,
                                     SERVER_PORT)

        # If server doesn't exist, disconnect from client and continue loop
        if not server:
            print "Could not connect to server. Closing connection to client."
            client.close()

        else:

            print "Connected to server at:", server.getpeername()
            # server.setblocking(0)
            # client.setblocking(0)
            # Dont calculate throughput until streaming movie
            calculate_tp = False

            while True:

                print('CLIENT SELECT')
                read_ready, _, _ = select.select([client, server], [], [])

                if client in read_ready:
                    print('READING CLIENT')
                    # If we were calculating throughput, log info
                    if calculate_tp:
                        # Update tp estimate
                        new_tp = calc_tp(ts, tf, n_bits)
                        self.tp_estimate = ewma(self.tp_estimate, new_tp,
                                                self.alpha)

                        # Last chunk/requested bit rate
                        chunkname = get_chunkname(client_msg)
                        req_bitrate = get_req_bitrate(chunkname)

                        log = generate_log(ts=ts,
                                           tf=tf,
                                           tput=new_tp,
                                           avg_tput=self.tp_estimate,
                                           req_bitrate=req_bitrate,
                                           server_ip=self.server_ip,
                                           chunkname=chunkname)

                        write_log(self.log_file, log)

                        print log

                    client_msg = receive(client, server, MAX_SIZE)

                    vid_req = is_vid_request(client_msg)

                    ##### Send Client Message #####

                    # Replace client request for f4m file
                    if 'big_buck_bunny.f4m' in client_msg:
                        client_msg = client_msg.replace('big_buck_bunny.f4m',
                                                        'big_buck_bunny_nolist.f4m')
                        print client_msg
                    elif vid_req:
                        client_msg = modify_uri_bitrate(client_msg,
                                                        self.bitrates,
                                                        self.tp_estimate)
                    try:
                        # Send to server
                        server.send(client_msg)
                    except:
                        break
                    print 'Data sent client --> server:', client_msg

                    ##### Start Calculating Throughput #####

                    # Start timing since we are waiting for server
                    if vid_req:
                        #print('VIDEO REQ')
                        calculate_tp = True
                        n_bits = 0
                        ts = time.time()
                    else:
                        calculate_tp = False

                #print('SERVER SELECT')
                #server_ready, _, _ = select.select([server], [], [])
                # Receive message from server
                if server in read_ready:
                    print('READING SERVER')
                    #print('READING SERVER')
                    server_msg = receive(server, client, MAX_SIZE)
                    print('DONE RECEIVING SERVER')
                    # print('Bits: {}'.format(bits(server_msg)))
                    # print('Length: {}'.format(get_length(server_msg)))

                    if calculate_tp:
                        n_bits += bits(server_msg)
                        tf = time.time()

                    try:
                        # Send to client
                        client.send(server_msg)
                        print 'Data sent server --> client:', server_msg[0:400]
                    except:
                        break

            # Close connections if break out of loop
            if server:
                server.close()
            if client:
                client.close()


if __name__ == '__main__':
    log = sys.argv[1]
    alpha = float(sys.argv[2])
    listen_port = int(sys.argv[3])
    fake_ip = sys.argv[4]
    server_ip = sys.argv[5]

    P = Proxy(log_file=log, alpha=alpha,
              listen_port=listen_port, fake_ip=fake_ip,
              server_ip=server_ip)
    P.run()
